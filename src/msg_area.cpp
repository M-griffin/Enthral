/***************************************************************************
 *   Copyright (C) 2004-2014 by Michael Griffin                            *
 *   mrmisticismo@hotmail.com                                              *
 *                                                                         *
 *   Purpose: Message Area Full Screen Listing                             *
 *                                                                         *
 *                                                                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 ***************************************************************************/

// Enthral SVN: $Id$
// Source: $HeadURL$
// $LastChangedDate$
// $LastChangedRevision$
// $LastChangedBy$

# include "struct.h"
# include "language.h"
# include "menu_func.h"
# include "msg_area.h"

# include <fstream>
# include <string>
# include <vector>

# include <cstdio>
# include <ctime>
# include <cctype>
# include <cstring>
# include <cstdlib>

using namespace std;

/**
 * Message Area INI - Check INI File Exists.
 */
bool msgarea_ini::msga_exists()
{

    iTop = 0;
    iBot = 0;

    strcpy ( sPAGENUM,"" );
    strcpy ( sPAGETOTAL,"" );
    strcpy ( sMOREUP,"" );
    strcpy ( sMOREUP_CHAR,"" );
    strcpy ( sMOREDOWN,"" );
    strcpy ( sMOREDOWN_CHAR,"" );
    strcpy ( sMOREMSG_ON,"" );
    strcpy ( sMOREMSG_WORD_ON,"" );
    strcpy ( sMOREMSG_OFF,"" );
    strcpy ( sMOREMSG_WORD_OFF,"" );
    strcpy ( sINPUT_BOX,"" );
    strcpy ( sTEXT_COLOR,"" );
    strcpy ( sTEXT_HILIGHT,"" );
    strcpy ( sMAX_AREAS,"" );
    strcpy ( sANSI_FILE,"" );
    strcpy ( sANSI_HELP,"" );
    strcpy ( sTHEME_NAME,"" );
    strcpy ( sMENU_PROMPT,"" );
    strcpy ( sMENU_PROMPT2,"" );


    std::string path = INIPATH;
    path += "msgarea.ini";

    FILE *stream;
    stream = fopen ( path.c_str(),"rb+" );

    if ( stream == NULL )
    {
        perror ( "Error unable to read msgarea.ini, check permissions!" );
        return false;
    }

    fclose ( stream );
    return true;
}

/**
 * Message Area INI - Generate Default INI (Deprecated)
 */
void msgarea_ini::msga_create()
{

    std::string name = INIPATH;
    name += "msgarea.ini";

    ofstream outStream2;
    outStream2.open ( name.c_str(), ofstream::out | ofstream::trunc );

    if ( !outStream2.is_open() )
    {
        printf ( "\nError Creating: %s \n", name.c_str() );
        return;
    }

    outStream2 << " * Generated By Program. " << endl;
    outStream2.close();
    return;
}

/**
 * MenuArea INI - Parse Helper
 */
void msgarea_ini::msga_chkpar ( std::string &data )
{

    std::string temp1;
    std::string::size_type st1 = 0;
    std::string::size_type st2 = 0;
    std::string::size_type ct  = 0;

    st1 = data.find ( '"', 0 );
    st2 = data.find ( '"', st1+1 );
    ++st1;
    temp1 = data.substr ( st1,st2 );
    ct = st2 - st1;

    if ( temp1.length() > ct )
        temp1.erase ( ct,temp1.length() );

    data = temp1;
}

/**
 * Message Area INI - Get INI Values
 */
void msgarea_ini::msga_check ( std::string cfgdata )
{

    int id1 = 0;
    std::string temp = cfgdata;

    if ( temp[0] == '#' ) return;
    else if ( temp.find ( "set TOP ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        id1 = atoi ( temp.c_str() );
        iTop = id1;
    }
    else if ( temp.find ( "set BOT ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        id1 = atoi ( temp.c_str() );
        iBot = id1;
    }
    else if ( temp.find ( "set THEME_NAME ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sTHEME_NAME, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set ANSI_FILE ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sANSI_FILE, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set ANSI_HELP ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sANSI_HELP, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set MENU_PROMPT ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sMENU_PROMPT, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set MENU_PROMPT2 ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sMENU_PROMPT2, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set PAGENUM ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sPAGENUM, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set PAGETOTAL ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sPAGETOTAL, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set MOREUP ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sMOREUP, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set MOREUP_CHAR ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sMOREUP_CHAR, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set MOREDOWN ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sMOREDOWN, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set MOREDOWN_CHAR ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sMOREDOWN_CHAR, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set MOREMSG_ON ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sMOREMSG_ON, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set MOREMSG_WORD_ON ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sMOREMSG_WORD_ON, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set MOREMSG_OFF ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sMOREMSG_OFF, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set MOREMSG_WORD_OFF ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sMOREMSG_WORD_OFF, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set INPUT_BOX ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sINPUT_BOX, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set TEXT_COLOR ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sTEXT_COLOR, ( char * ) temp.c_str() );
    }
    else if ( temp.find ( "set MAX_AREAS ", 0 ) != std::string::npos )
    {
        msga_chkpar ( temp );
        strcpy ( sMAX_AREAS, ( char * ) temp.c_str() );
    }
}

/**
 * Message Area INI - Read & Parse INI File
 */
int msgarea_ini::msga_parse ( int idx )
{

    if ( !msga_exists() )
    {
        perror ( "Error unable to read msgarea.ini, check permissions!" );
        return 0;
    }

    //msga_create();

    char name[255]= {0};
    char name2[255]= {0};

    sprintf ( name,"%smsgarea.ini",INIPATH );
    sprintf ( name2,"%smsgarea%i.ini",INIPATH,idx );

    if ( idx != 0 ) strcpy ( name,name2 );

    // Check if Theme Exists, if not return FALSE.
    FILE *stream;
    stream = fopen ( name,"rb+" );

    if ( stream == NULL ) // File is not Present
    {
        return FALSE;
    }
    else
    {
        fclose ( stream );
    }

    ifstream inStream;
    inStream.open ( name );

    if ( !inStream.is_open() )
    {
        perror ( "Error unable to parse msgarea.ini, check permissions!" );
        return FALSE;
    }

    std::string cfgdata;

    for ( ;; )
    {
        getline ( inStream,cfgdata );
        msga_check ( cfgdata );

        if ( inStream.eof() ) break;
    }

    inStream.close();
    return TRUE;
}


/**
 * Message Area - Read & Parse INI File
 */
msg_area::msg_area()
{

    tTop     = 1;
    tBot     = 1;
}


/**
 * Message Area - Startup
 */
void msg_area::init_db()
{


    /*
    bbs_cfg bcfg;
    bcfg.parseconfig();

    // Setup in Config file now.
    std::string node = bcfg.SQL_LOGINSERVER,
        base = bcfg.SQL_DATABASENAME,
        user = bcfg.SQL_LOGINNAME,
        pass = bcfg.SQL_LOGINPASSWORD;

    StderrLog       log;
    std::string     err;
    Database::Mutex mutex;

    Database db(mutex,node,user,pass,base, (IError*)&log);
    Query q(db);
    if (!q.Connected()) {
        cout << "\r\nSQL: Not Connected!" << endl;
    }
    StartList(q);
    */
    StartList();
}

/**
 * Message Area - Read Areas and populate vector list.
 * along with status and flags.
 */
vector< mb_list_rec > msg_area::read_areas()
{

    /*
    bbs_cfg bcfg;
    bcfg.parseconfig();

    // Setup in Config file now.
    std::string node = bcfg.SQL_LOGINSERVER,
        base = bcfg.SQL_DATABASENAME,
        user = bcfg.SQL_LOGINNAME,
        pass = bcfg.SQL_LOGINPASSWORD;

    StderrLog       log;
    std::string     err;
    Database::Mutex mutex;

    Database db(mutex,node,user,pass,base, (IError*)&log);
    Query q(db);
    if (!q.Connected()) {
        cout << "\r\nSQL: Not Connected!" << endl;
    }*/

    SESSION s;
    mb_list_rec mbl;
    std::vector< mb_list_rec > result;

//    s . errlog((char *)"read_areas");

    ulong idx = 0; //Start at 1, 0 is Email, skip email is public area listing

    while ( read_mbaselist ( &mbl,idx ) )
    {
        mbl . idx = idx;
        result . push_back ( mbl );
        ++idx;
    }

    /*
        ulong in = 0;
        q . get_result("SELECT msg_area, msg_desc, msg_type, msg_status, msg_group_id, msg_security_id FROM marea_cfg order by sortorder");
        ulong numrows = q . num_rows(); // get how many rows returned.

        //cout << "\r\nNumrows: " << numrows << endl;
        s . errlog((char *)"Numrows: ",numrows);

        in = 0;
        while(q . fetch_row()) {
            //s . errlog((char *)"loop");
            ++in;
            std::string str;

            str = q . getstr(0);
            //s . errlog((char *)"msg_area: %s",str.c_str());
            snprintf((char *)mbl . msg_area, sizeof(mbl . msg_area), "%s", str.c_str());

            str = q . getstr(1);
            //s . errlog((char *)"msg_desc: %s",str.c_str());
            snprintf((char *)mbl . msg_desc, sizeof(mbl . msg_desc), "%s", str.c_str());

            mbl . msg_type         = q . getval(2);
            mbl . msg_status       = q . getval(3);
            mbl . msg_group_id     = q . getval(4);
            mbl . msg_security_id  = q . getval(5);

            result . push_back(mbl);
        }


        //s . errlog((char *)"read_areas cnt: %lu", in);
        q . free_result();

        s . errlog((char *)"read_areas Done!");

        // Just looping through to test results not really needed.
        ulong max_areas = result.size();
        s . errlog((char *)"vector max_areas: %lu",max_areas);
    */


    /*  Testing.
    for (ulong i = 0; i != max_areas; i++) {
        s . errlog((char *)"vector str1: %s",(char *)result[i].msg_area);
        s . errlog((char *)"vector str2: %s",(char *)result[i].msg_desc);
    } */
    return result;
}


/**
 * Message Area - Builds Message Areas And Returns Vecotrs of
 *                Ansi Lightbars for (4) Different States
 *                User is shown 1 of 4 depending on the curent
 *                area and if there are new messages.
 */
vector< list_bar > msg_area::build_arealist ( UserRec *usr, std::string &temp ) //, Query &qry) {
{

    mb_list_rec mbl;

    list_bar                 mbar;
    std::vector<list_bar>    result;
    std::vector<mb_list_rec> mareas;

    SESSION       s ( usr ); // Pass User Incase there are MCI Codes for User Info.

//    s . errlog((char *)" * build_areas * ");

    int c = 0;
    //std::string temp = "";
    std::string path  = "";
    std::string temp3 = "";
    temp.erase();


    FILE *inStream;
    long  idx = 1;
    long  cnt = 0;
    long  i   = 0;
//    long  basenum = 0;
//    long  lr  = 0;

    char  MCI[3]= {0};
    char  temp2[100]= {0};
    int   space  = 0;
    int   foundr = FALSE;
    int   foundl = FALSE;
//    int   reset  = FALSE;
//    int   dont   = FALSE;

    std::string ans  = "";
    std::string ans1 = "";
    std::string ans2 = "";
    std::string ans3 = "";
    std::string ans4 = "";

    // Prefetch ansi's
    path = ANSIPATH;
    path += "mareamid1.ans";

    if ( ( inStream = fopen ( path.c_str(), "r+" ) ) ==  NULL )
    {
        return result;
    }

    while ( c != EOF )
    {
        c = getc ( inStream );

        if ( c != EOF ) ans1 += c;
    }

    fclose ( inStream );
    c = '\0';
    path = ANSIPATH;
    path += "mareamid2.ans";

    if ( ( inStream = fopen ( path.c_str(), "r+" ) ) ==  NULL )
    {
        return result;
    }

    while ( c != EOF )
    {
        c = getc ( inStream );

        if ( c != EOF ) ans2 += c;
    }

    fclose ( inStream );
    c = '\0';
    path = ANSIPATH;
    path += "mareamid3.ans";

    if ( ( inStream = fopen ( path.c_str(), "r+" ) ) ==  NULL )
    {
        return result;
    }

    while ( c != EOF )
    {
        c = getc ( inStream );

        if ( c != EOF ) ans3 += c;
    }

    fclose ( inStream );
    c = '\0';
    path = ANSIPATH;
    path += "mareamid4.ans";

    if ( ( inStream = fopen ( path.c_str(), "r+" ) ) ==  NULL )
    {
        return result;
    }

    while ( c != EOF )
    {
        c = getc ( inStream );

        if ( c != EOF ) ans4 += c;
    }

    fclose ( inStream );

    int area_cnt = 0;

    /*
    qry.get_result("SELECT COUNT(*) FROM marea_cfg");
    qry.fetch_row();
    basenum = qry.getval();
    qry.free_result();
    */
    //while(read_mbaselist(&mb,idx)) {
    // Read All Areas
    mareas          = read_areas();

    long num_areas = 0;
    long max_areas = mareas.size();


    //s . errlog((char *)"build_arealist basenum   %lu", basenum);
//    s . errlog((char *)"build_arealist max_areas %lu", max_areas);
    usr->lastmsg = 0;

    while ( area_cnt < max_areas )
    {

        if ( num_areas == max_areas ) break;

        mbl = mareas[num_areas];

//        s . errlog((char *)"build_arealist mbl . idx %lu", mbl.idx);

        ++num_areas;
        ++idx;

        ans = ans2; // Display HighLight None.
        ans = ans1; // Dispaly Lowlight None

        ans = ans4; // Dispaly HighLight (New Messages)
        ans = ans3; // Dispaly LowLight (New Messages)

//        reset = FALSE;
        temp3.erase();


        for ( int icnt = 0; icnt < 4; icnt++ )
        {

            switch ( icnt )
            {
                case 0:
                    ans = ans2;
                    break; // Display HighLight None.  ON

                case 1:
                    ans = ans1;
                    break; // Dispaly Lowlight None    OFF

                case 2:
                    ans = ans4;
                    break; // Dispaly HighLight (New Messages)  ON

                case 3:
                    ans = ans3;
                    break; // Dispaly LowLight (New Messages)   OFF

                default:
                    break;
            }

            i = 0;
            c = 0;

            do
            {
                memset ( &MCI,0,sizeof ( MCI ) );
                c = ans[i];

                if ( c == '\0' ) break;

                // Check for Spacing MCI Code
                switch ( c )
                {
                    case '{' : // Left Justify
                        MCI[0] = ans[++i];
                        MCI[1] = ans[++i];
                        space = atoi ( MCI );

                        if ( space != 0 )
                        {
                            foundl = TRUE;
                        }
                        else
                        {
                            temp3 += c;
                            temp3 += MCI;
                        }

                        break;

                    case '}' : // Right Justify
                        MCI[0] = ans[++i];
                        MCI[1] = ans[++i];
                        space = atoi ( MCI );

                        if ( space != 0 )
                        {
                            foundr = TRUE;
                        }
                        else
                        {
                            temp3 += c;
                            temp3 += MCI;
                        }

                        break;

                    case '|' : // Pipe Codes
                        MCI[0] = ans[++i];
                        MCI[1] = ans[++i];

                        if ( strcmp ( MCI,"M#" ) == 0 )
                        {
                            sprintf ( temp2,"%i",area_cnt+1 );

                            if ( foundl )
                            {
                                s.lspacing ( temp2,space );
                                foundl = FALSE;
                            }
                            else if ( foundr )
                            {
                                s.rspacing ( temp2,space );
                                foundr = FALSE;
                            }

                            temp3 += temp2;
                        }
                        else if ( strcmp ( MCI,"MA" ) == 0 )
                        {
                            sprintf ( temp2,"%s", ( char * ) mbl . mbdisplay );

                            if ( foundl )
                            {
                                s.lspacing ( temp2,space );
                                foundl = FALSE;
                            }
                            else if ( foundr )
                            {
                                s.rspacing ( temp2,space );
                                foundr = FALSE;
                            }

                            temp3 += temp2;
                        }
                        else if ( strcmp ( MCI,"MT" ) == 0 )
                        {
                            cnt = CountMsgs ( mbl . idx,usr );

                            if ( cnt == -1 ) cnt = 0;

                            //else ++cnt;
                            sprintf ( temp2,"%ld",cnt );

                            if ( foundl )
                            {
                                s.lspacing ( temp2,space );
                                foundl = FALSE;
                            }
                            else if ( foundr )
                            {
                                s.rspacing ( temp2,space );
                                foundr = FALSE;
                            }

                            temp3 += temp2;
                        }
                        else if ( strcmp ( MCI,"MN" ) == 0 )
                        {

                            // Count how many unread messages
                            cnt = CountNewMsgs ( mbl . idx,usr );

                            /*
                            if (cnt == -1) cnt = 0;
                            //else ++cnt;

                            lr = JamAreaGetLast(usr->idx,&mbl);
                            lr = 0;
                            if (lr == -1)   lr = 0;
                            if (lr > cnt )  lr = cnt;
                            else if (lr != 0) --lr;
                            if (cnt == 0)   lr = 0;

                            // Re-Process and Reset to Correct Mid Ansi
                            //if (cnt-lr >= 1 && reset == FALSE && (ans != ans2 || ans != ans4)) {
                            //    reset = TRUE;
                            //    goto RESTART;
                            //}

                            */

                            // sprintf(temp2,"%ld",cnt-lr);
                            sprintf ( temp2,"%ld",cnt );

                            if ( foundl )
                            {
                                s.lspacing ( temp2,space );
                                foundl = FALSE;
                            }
                            else if ( foundr )
                            {
                                s.rspacing ( temp2,space );
                                foundr = FALSE;
                            }

                            // New Messages Setup count
                            if ( cnt == 0 ) // no new
                            {
                                mbar.isnew = FALSE;
                            }
                            else
                            {
                                mbar.isnew = TRUE;
                            }

                            temp3 += temp2;
                        }
                        else
                        {
                            temp3 += c;
                            temp3 += MCI;
                        }

                        break;

                    case '\n' :
                        //  temp3 += '\r';
                        break;

                    default :
                        temp3 += c;
                        break;
                }

                ++i;

            }
            while ( c != '\0' );

            temp3 += "\r";

            switch ( icnt )
            {
                case 0:
                    mbar . ansi_2 = temp3;
                    break; // Display HighLight None.  ON

                case 1:
                    mbar . ansi_1 = temp3;
                    break; // Dispaly Lowlight None    OFF

                case 2:
                    mbar . ansi_4 = temp3;
                    break; // Dispaly HighLight (New Messages)  ON

                case 3:
                    mbar . ansi_3 = temp3;
                    break; // Dispaly LowLight (New Messages)   OFF

                default:
                    break;
            }

            //result . push_back(mbar);
            //temp += temp3;
            temp3.erase();

        } // End of (4) Look for each string.

        /*
        s . errlog((char *)"mbar: 1 %s",mbar . ansi_1.c_str());
        s . errlog((char *)"mbar: 2 %s",mbar . ansi_2.c_str());
        s . errlog((char *)"mbar: 3 %s",mbar . ansi_3.c_str());
        s . errlog((char *)"mbar: 4 %s",mbar . ansi_4.c_str());


        s . pipe2ansi((char *)mbar . ansi_1.c_str());
        s . pipe2ansi((char *)mbar . ansi_2.c_str());
        s . pipe2ansi((char *)mbar . ansi_3.c_str());
        s . pipe2ansi((char *)mbar . ansi_4.c_str());
        */
        //s . startpause();

        result . push_back ( mbar );
        temp3.erase();

        ++area_cnt;
        //s . errlog((char *)"area_cnt: %i",area_cnt);

    }

    // Update Clear Screen
//    s . errlog((char *)"build_areas Done!");
//    s . errlog((char *)"Done, import - return result vector list");
    return result;
}



/**
 * Message Areas - Parse ANSI Tempalte for MCI Codes (Area List)
 */
void msg_area::ParseHeader ( char *filename )
{

    std::string temp;
    std::string path = ANSIPATH;
    path += filename;
    path += ".ans";

    mb_list_rec mr;

    char MCI[3]     = {0};   // Holds MCI Codes to Parse
    char sTemp[255] = {0};
    int  space = 0, foundr = 0 , foundl = 0;
//    int  c = 0;
    std::string buff;

    // Reads in Ansi file into Buffer Only
    readinAnsi ( filename, buff );
    read_mbaselist ( &mr, thisuser->lastmbarea );

    int id1 = 0;

    while ( id1 != -1 )
    {
        // parse justify spacing right / left passing in string before
        // replacing mci code. to Properly Space Output Ansi.
        id1 = buff.find ( "%", 0 );

        if ( id1 == -1 ) break;

        memset ( &MCI,0,sizeof ( MCI ) );
        space = 0;

        // Check if MCI Code is Justified then Process this.
        if ( buff[id1+3] == '{' ) // Left Justify
        {
            //elog("left justify: %c%c",buff[id1+4],buff[id1+5]);
            MCI[0] = buff[id1+4]; // Get first Digit
            MCI[1] = buff[id1+5]; // Get Second Digit
            space  = atoi ( MCI );
            foundr = FALSE;
            foundl = TRUE;
        }
        else if ( buff[id1+3] == '}' ) // Right Justify
        {
            //elog("right justify: %c%c",buff[id1+4],buff[id1+5]);
            MCI[0] = buff[id1+4]; // Get first Digit
            MCI[1] = buff[id1+5]; // Get Second Digit
            space  = atoi ( MCI );
            //elog("right justify: %i",space);
            foundl = FALSE;
            foundr = TRUE;
        }

        // Now Get MCI Code
        MCI[0] = buff[id1+1]; // Get first Digit
        MCI[1] = buff[id1+2]; // Get Second Digit

        memset ( &sTemp,0,sizeof ( sTemp ) );

        // Insert MCI Parsing here so we can reaplace full result with propering spacing.
        if ( strcmp ( MCI,"MA" ) == 0 )
        {
            sprintf ( sTemp,"%s", ( char * ) mr.mbdisplay );
        }
        else if ( strcmp ( MCI,"TH" ) == 0 )
        {
            sprintf ( sTemp,"%s", ( char * ) sTHEME_NAME );
        }


        // MCI Translation .
        if ( foundl == TRUE )
        {
            lspacing ( sTemp,space );
        }
        else if ( foundr == TRUE )
        {
            rspacing ( sTemp,space );
        }

        //If we Parsed Justify, then Erase that MCI Code as well.
        ( space != 0 ) ?
        buff.replace ( id1,6,sTemp ) :
        buff.replace ( id1,3,sTemp );
    }

    //elog("Finished Parsing MCI Codes...");
    pipe2ansi ( ( char * ) buff.c_str() );
}

/**
 * Message Areas - Setup The Area List,
 * Also check default Ansi Theme and set per user
 */
void msg_area::SetupList ( UserRec *user )
{

    thisuser = user;

    // Check What Theme user has selected.
    if ( msga_parse ( thisuser->readertheme ) == FALSE )
    {
        msga_parse();
    }

    tTop = iTop;
    tBot = iBot;
}

/**
 * Message Areas - Change Ansi Theme if available.
 */
int msg_area::change_theme ( int idx )
{

    // Check What Theme user has selected.
    if ( msga_parse ( idx ) == FALSE )
    {
        // Theme Doesn't Exist.
        return FALSE;
    }

    thisuser->readertheme = idx;

    // Save User Settings.
    UserRec usr;
    usr = *thisuser;
    users _usr;
    _usr.users_write ( &usr,usr.idx );

    tTop = iTop;
    tBot = iBot;
    mLink.Top = tTop;
    mLink.Bot = tBot;
    return TRUE;
}


/**
 * Message Areas - Area List Startup.
 */
char *msg_area::StartList()
{

    bool more          = false;
    bool showmore    = false;
    char mString[10] = {0};
    unsigned char ch;
    std::string _output;
    char outBuffer[200];

    // Startup Friend Classes
    //language    _lang;
    menu_func   _mnuf;
    msg_readll  mLink;

    // Save User Settings.
    UserRec usr;
    usr = *thisuser;
    users _usr;

    // Then ReRead before passing copy to message system.
    _usr.users_write ( thisuser,thisuser->idx );
    _usr.users_read ( &usr,thisuser->idx );

//     errlog((char *)"Build AreaList - ThisUserID %lu, %s",usr.idx, usr.handle);

    SESSION s ( &usr );

    _mnuf.menu_setuser ( thisuser );
    mLink.initList ( sTEXT_COLOR, TRUE );

    mLink.Top = tTop;
    mLink.Bot = tBot;

    char rBuffer[1024]= {0};
    char text[1024]= {0};
    char sNum[3]= {0};
    std::string rBuff;

    std::string::size_type id1 = 0; //id2,
//    int num, num2;
    int len;

    std::string tmp;
//    UserRec trec;

    // For Next / Prev Message Areas
    int CurrentPage  = 0;
//    int PreviousPage = 0;
    int bSize        = 0;
    int boxsize      = 0;

    bSize = tBot - tTop;
    ++bSize;


    //CURRENT_MAREA   = 0;
    //usr.lastmbarea = 0;

    // Run through Main Loop until exit from user - This Loop Probably not needed anymore.
    vector<list_bar> result;

//    errlog((char *)"Build AreaList - UserID %lu, %lu",usr.idx, usr.handle);
    result = build_arealist ( &usr, tmp ); //, qry);

    mLink.GetVector ( result );

    while ( 1 )
    {
        // Jump to Current Page
        boxsize =  mLink.Bot - mLink.Top;
        CurrentPage = CURRENT_MAREA / boxsize;

        ParseHeader ( sANSI_FILE );       // Display Ansi
        //tmp.erase();

//        errlog((char *)"PutBuffer msg_area()");
        //  Make sure we have areas.
        if ( result.size() > 0 )
        {
            mLink.box_start_vector ( CurrentPage,CURRENT_MAREA );         // Draw Message Inside of Box
        }
        else
        {
            return NULL;
        }

//        errlog((char *)"box_start done msg_area()");
        // Start Input Loop.
        while ( 1 )
        {
            _output.erase();
            _output = "|16";
            more = false;
            showmore = false;

            //if (mLink.line_count() > 0) more = true;
            if ( mLink.Page+1 != mLink.TotPages ) more = true;

            // Show Down Arrow More!
            if ( more )
            {
                sprintf ( outBuffer,"%s\x19",sMOREDOWN );     // On
                showmore = true;
            }
            else
            {
                sprintf ( outBuffer,"%s ",sMOREDOWN );        // Off
            }

            _output += outBuffer;

            // Show up Arrow More
            if ( mLink.Page > 0 )
            {
                sprintf ( outBuffer,"%s\x18",sMOREUP );
                showmore = true;
            }
            else
            {
                sprintf ( outBuffer,"%s ",sMOREUP );
            }

            _output += outBuffer;

            if ( showmore )
                sprintf ( outBuffer,"%s%s",sMOREMSG_ON,sMOREMSG_WORD_ON );
            else
                sprintf ( outBuffer,"%s%s",sMOREMSG_OFF,sMOREMSG_WORD_OFF );

            _output += outBuffer;

            // Show Current/Total Pages
            sprintf ( outBuffer,"%s%.3d",sPAGENUM,mLink.Page+1 );
            _output += outBuffer;
            sprintf ( outBuffer,"%s%.3d",sPAGETOTAL,mLink.TotPages );
            _output += outBuffer;

            // # of Message Areas
            sprintf ( outBuffer,"%s%d",sMAX_AREAS,mLink.Tot );
            _output += outBuffer;

            pipe2ansi ( ( char * ) _output.c_str() );

            // Blank out the previous menu so we can reload, / redraw on restart.
            //memset(&_mnuf._premenu,0,sizeof(_mnuf._premenu));

            // Make Msgqp2 Prompt Optional, Use if exists!
            // Also Let user Toggle on / off
            if ( _mnuf.cmdexist ( sMENU_PROMPT2,0 ) /*&& thisuser->msgp2*/ )
            {
                if ( more || mLink.Page > 1 )
                {
                    _mnuf._curmenu.clear();
                    _mnuf._curmenu = sMENU_PROMPT2;
                }
                else
                {
                    _mnuf._curmenu.clear();
                    _mnuf._curmenu = sMENU_PROMPT;
                }
            }
            else
            {
                _mnuf._curmenu.clear();
                _mnuf._curmenu = sMENU_PROMPT;
            }

            // Readin the Menu Prompt and get or wait for input.
// So we don't reload all of the menu and propmts for a bad key, just ask again!
        JMPINPUT:

            // Draw Input Box
            memset ( &text,0, sizeof ( text ) );
            strcpy ( text,sINPUT_BOX );

            sprintf ( outBuffer,"%d",mLink.Tot );
            len = strlen ( outBuffer ) +1; // Last Ourbuf is Message Number
            inputfield ( text,len );

            _output = text;
            _output += "|16";
            pipe2ansi ( ( char * ) _output.c_str() );


            _mnuf.menu_readin();
            _mnuf.menu_proc ( mString );
            ch = mString[1];

            // For Menu CmdKey Input
            if ( mString[0] == '!' )
            {
                switch ( toupper ( ch ) )
                {
                    case 'Q': // Quit
                        mLink.dispose_list();
                        //_mnuf.~menu_func();
                        memcpy ( thisuser,&usr,sizeof ( UserRec ) );
//                        errlog((char *)thisuser->handle);
                        vector<list_bar>() . swap ( result ); // Free Vector Up.
                        return NULL; //qBuf;

                    case 'U':  // UP
                        if ( CurrentPage != 0 )
                        {
                            --CurrentPage;

                            // Reset Bar to first Listing on each Page.
                            // CurrentPage = CURRENT_MAREA / boxsize;
                            CURRENT_MAREA = CurrentPage * boxsize;
                            mLink.box_start_vector ( CurrentPage,CURRENT_MAREA );
                        }
                        else
                            goto JMPINPUT;

                        break;

                    case 'D': // DN
                        if ( CurrentPage+1 != mLink.TotPages )
                        {
                            ++CurrentPage;

                            // Reset Bar to first Listing on each Page.
                            // CurrentPage = CURRENT_MAREA / boxsize;
                            CURRENT_MAREA = CurrentPage * boxsize;
                            mLink.box_start_vector ( CurrentPage,CURRENT_MAREA );
                        }
                        else
                            goto JMPINPUT;

                        break;

                    case '+': // Next Area - Move Down

//                        s . errlog((char *)"CURRENT_MAREA+1: %i. Listing: %i ", CURRENT_MAREA+1,mLink.listing.size());
                        if ( CURRENT_MAREA+1 == ( signed ) mLink.listing.size() || ( signed ) mLink.listing.size() == 0 )
                            goto JMPINPUT;

                        ++CURRENT_MAREA;
                        thisuser->lastmbarea = CURRENT_MAREA;

//                        s . errlog((char *)"CurrentPage: %i. PreviousPage: %i ", CurrentPage, PreviousPage);
//                        s . errlog((char *)"boxsize: %i. TotPages: %i. Page: %i ", boxsize, mLink.TotPages,  mLink.Page);
//                    PreviousPage = CurrentPage;

                        //Calculate if we go down, ++Current Area, are we on next page or not.
                        // Becasue 0 Based, need to add +1
                        // Test if we moved to next page.
                        if ( CURRENT_MAREA+1 < ( boxsize* ( CurrentPage+1 ) ) +1 )
                        {
                            // Still on Same Page
                            if ( mLink.listing[CURRENT_MAREA-1].isnew )
                            {
//                                errlog((char *)"!!! isNEW = 'Y' 3");
//                                s . errlog((char *)"CURRENT_MAREA+1 %i < (boxsize*CurrentPage+1)+1, %i",CURRENT_MAREA+1,boxsize*(CurrentPage+1)+1);
                                // Lowlight Current, then Highlight Next.
                                sprintf ( rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, ( char * ) mLink.listing[CURRENT_MAREA-1].ansi_3.c_str() );
//                                s . errlog((char *)rBuffer);
                            }
                            else
                            {
//                                errlog((char *)"!!! isNEW = 'N' 1");
//                                s . errlog((char *)"CURRENT_MAREA+1 %i < (boxsize*CurrentPage+1)+1, %i",CURRENT_MAREA+1,boxsize*(CurrentPage+1)+1);
                                // Lowlight Current, then Highlight Next.
                                sprintf ( rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, ( char * ) mLink.listing[CURRENT_MAREA-1].ansi_1.c_str() );
//                                s . errlog((char *)rBuffer);
                            }

                            _output += rBuffer;
                            mLink.current_selection += 1;

                            if ( mLink.listing[CURRENT_MAREA].isnew )
                            {
///                                errlog((char *)"!!! isNEW = 'Y' 4");
                                sprintf ( rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, ( char * ) mLink.listing[CURRENT_MAREA].ansi_4.c_str() );
//                                s . errlog((char *)rBuffer);
                            }
                            else
                            {
//                                errlog((char *)"!!! isNEW = 'N' 2");
                                sprintf ( rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, ( char * ) mLink.listing[CURRENT_MAREA].ansi_2.c_str() );
//                                s . errlog((char *)rBuffer);
                            }

                            _output += rBuffer;
                            pipe2ansi ( ( char * ) _output.c_str() );
                            _output.erase();
                            goto JMPINPUT; //Not moving down a page.
                        }
                        else
                        {
                            // Move to next Page!
//                            s . errlog((char *)"DN - CURRENT_MAREA !< Move next Page");
                            ++CurrentPage;
                            mLink.box_start_vector ( CurrentPage,CURRENT_MAREA );
                        }

                        break;

                    case '-': // Previous Area - Move Up

                        // Skipping to JMPINPUT bypasses redraws, much faster!
                        if ( CURRENT_MAREA != 0 )
                            --CURRENT_MAREA;
                        else
                            goto JMPINPUT;

                        if ( mLink.listing.size() == 0 )
                            goto JMPINPUT;

                        thisuser->lastmbarea = CURRENT_MAREA;

//                        s . errlog((char *)"!!! CurrentPage: %i. PreviousPage: %i ", CurrentPage, PreviousPage);
//                        s . errlog((char *)"boxsize: %i. TotPages: %i. Page: %i ", boxsize, mLink.TotPages,  mLink.Page);
//                    PreviousPage = CurrentPage;

//                        s . errlog((char *)"!!! CurrentPage: %i. PreviousPage: %i ", CurrentPage, PreviousPage);
                        //Calculate if we go down, --Current Area, are we on next page or not.
                        // Becasue 0 Based, need to add +1
                        // Test if we moved to next page.
                        if ( CURRENT_MAREA+1 > ( boxsize* ( CurrentPage ) ) )
                        {
                            // Still on Same Page
//                            s . errlog((char *)"CURRENT_MAREA+1 %i > (boxsize*CurrentPage+1)+1, %i",CURRENT_MAREA+1, ((boxsize*CurrentPage)+1) );
                            // Lowlight Current, then Highlight Next.
                            if ( mLink.listing[CURRENT_MAREA+1].isnew )
                            {
//                                errlog((char *)"!!! isNEW = 'Y' 1");
                                sprintf ( rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, ( char * ) mLink.listing[CURRENT_MAREA+1].ansi_3.c_str() );
//                                s . errlog((char *)rBuffer);
                            }
                            else
                            {
//                                errlog((char *)"!!! isNEW = 'N' 3");
                                sprintf ( rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, ( char * ) mLink.listing[CURRENT_MAREA+1].ansi_1.c_str() );
//                                s . errlog((char *)rBuffer);
                            }

                            _output = rBuffer;
                            mLink.current_selection -= 1;

                            if ( mLink.listing[CURRENT_MAREA].isnew )
                            {
//                                errlog((char *)"!!! isNEW = 'Y' 4");
                                sprintf ( rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, ( char * ) mLink.listing[CURRENT_MAREA].ansi_4.c_str() );
//                                s . errlog((char *)rBuffer);
                            }
                            else
                            {
//                                errlog((char *)"!!! isNEW = 'N' 2");
                                sprintf ( rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, ( char * ) mLink.listing[CURRENT_MAREA].ansi_2.c_str() );
//                                s . errlog((char *)rBuffer);
                            }

                            _output += rBuffer;

                            pipe2ansi ( ( char * ) _output.c_str() );
                            _output.erase();
//                            s . errlog((char *)"CurrentPage: %i. PreviousPage: %i ", CurrentPage, PreviousPage);
//                            s . errlog((char *)"boxsize: %i. TotPages: %i. Page: %i ", boxsize, mLink.TotPages,  mLink.Page);
                            goto JMPINPUT; //Not moving down a page.
                            break;
                        }
                        else
                        {
                            // Move to next Page!
//                            s . errlog((char *)"2!!!! UP - CURRENT_MAREA !< Move prev Page");
//                            s . errlog((char *)"First CurrentPage: %i. PreviousPage: %i ", CurrentPage, PreviousPage);
                            --CurrentPage;
//                            s . errlog((char *)"Now CurrentPage: %i. PreviousPage: %i ", CurrentPage, PreviousPage);
//                            s . errlog((char *)"boxsize: %i. TotPages: %i. Page: %i ", boxsize, mLink.TotPages,  mLink.Page);

                            mLink.box_start_vector ( CurrentPage,CURRENT_MAREA );
                            //goto JMPINPUT;
                        }

                        break;

                    default : // Executing a menu command and returning back to list.
                        //goto JMPINPUT;
                        vector<list_bar>() . swap ( result ); // Free Vector Up.
                        tmp.erase();
                        result = build_arealist ( &usr, tmp ); //, qry);
                        mLink.GetVector ( result );

                        ParseHeader ( sANSI_FILE );
                        mLink.box_start_vector ( CurrentPage,CURRENT_MAREA );
                        break;
                } // End Switch
            } // of IF [!]
            else
            {
                if ( mString[0] == '#' )
                {
//                    s . errlog((char *)"# - CURRENT_MAREA ");
                    // received Digit Input From Menu Prompt
                    memset ( &rBuffer,0, sizeof ( rBuffer ) );
                    memset ( &text,0, sizeof ( text ) );
                    strcpy ( text,sINPUT_BOX );

                    sprintf ( outBuffer,"%d",mLink.Tot );
                    len = strlen ( outBuffer ) +1; // Last Ourbuf is Message Number

                    inputfield ( text,len );
                    pipe2ansi ( text );
                    sprintf ( sNum,"%c",ch );
                    getline ( rBuffer,len,sNum );
//                    num = 0;
//                    num2 = 0;
                    // Catch any invalid input
                    id1 = atoi ( rBuffer );

                    //if (id1 == 0)
                    //goto JMPINPUT;

                    // Verify Area Input Range.
                    if ( id1 > mLink.listing.size() || id1 < 1 )
                    {
//                        s . errlog((char *)"# - Incorrect Input");
                        // Redraw input box
                        memset ( &text,0, sizeof ( text ) );
                        strcpy ( text,sINPUT_BOX );

                        sprintf ( outBuffer,"%d",mLink.Tot );
                        len = strlen ( outBuffer ) +1; // Last Ourbuf is Message Number

                        inputfield ( text,len );
                        pipe2ansi ( text );
                        goto JMPINPUT;
                    }
                    else
                    {
//                        s . errlog((char *)"# - Jump to area id1 %i",id1);
                        //Justjump to area, then reset to page that area is in.
                        CURRENT_MAREA = id1-1;
                        thisuser->lastmbarea = CURRENT_MAREA;

                        // Jump to Current Page
                        CurrentPage = CURRENT_MAREA / boxsize;
//                        s . errlog((char *)"# - Jump to area box_start_vector - CurrentPage %i",CurrentPage);
                        ParseHeader ( sANSI_FILE );
                        mLink.box_start_vector ( CurrentPage,CURRENT_MAREA );
                        //           mLink.box_start_vector(CurrentPage);
                    }
                } // End if [#]
                else
                {
                    // Not #, Check for Escaped Key Input

                    ch = mString[0];

                    switch ( toupper ( ch ) )
                    {
                        case 'A':  // UP
                            if ( CurrentPage != 0 )
                            {
                                --CurrentPage;

                                // Reset Bar to first Listing on each Page.
                                CURRENT_MAREA = CurrentPage * boxsize;
                                mLink.box_start_vector ( CurrentPage,CURRENT_MAREA );
                            }
                            else
                                goto JMPINPUT;

                            break;

                        case 'B': // DN
                            if ( CurrentPage+1 != mLink.TotPages )
                            {
                                ++CurrentPage;
                                // Reset Bar to first Listing on each Page.
                                CURRENT_MAREA = CurrentPage * boxsize;
                                mLink.box_start_vector ( CurrentPage,CURRENT_MAREA );
                            }
                            else
                                goto JMPINPUT;

                            break;

                        default :

                            vector<list_bar>() . swap ( result ); // Free Vector Up.
                            tmp.erase();
                            result = build_arealist ( &usr, tmp ); //, qry);
                            mLink.GetVector ( result );

                            ParseHeader ( sANSI_FILE );
                            mLink.box_start_vector ( CurrentPage,CURRENT_MAREA );
                            break;

                    } // End Case
                }// End Else # or hokey.
            }// End of If Else [!]
        } // While(1)
    } // While(1) with redraw ansi
}
