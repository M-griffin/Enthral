/***************************************************************************
 *   Copyright (C) 2004-2014 by Michael Griffin                            *
 *   mrmisticismo@hotmail.com                                              *
 *                                                                         *
 *   Purpose: Message Area Full Screen Listing                             *
 *                                                                         *
 *                                                                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 ***************************************************************************/

// Enthral SVN: $Id: msg_area.cpp 1 2014-03-29 07:30:21Z mercyful $
// Source: $HeadURL: file:///home/merc/repo/enthral/trunk/src/msg_area.cpp $
// $LastChangedDate: 2014-03-29 02:30:21 -0500 (Sat, 29 Mar 2014) $
// $LastChangedRevision: 1 $
// $LastChangedBy: mercyful $

# include "struct.h"
# include "language.h"
# include "menu_func.h"
# include "msg_area.h"

# include <fstream>
# include <string>
# include <vector>

# include <cstdio>
# include <ctime>
# include <cctype>
# include <cstring>
# include <cstdlib>

using namespace std;

/**
 * Message Area INI - Check INI File Exists.
 */
bool msgarea_ini::msga_exists()
{

    iTop = 0;
    iBot = 0;

    strcpy(sPAGENUM,"");
    strcpy(sPAGETOTAL,"");
    strcpy(sMOREUP,"");
    strcpy(sMOREUP_CHAR,"");
    strcpy(sMOREDOWN,"");
    strcpy(sMOREDOWN_CHAR,"");
    strcpy(sMOREMSG_ON,"");
    strcpy(sMOREMSG_WORD_ON,"");
    strcpy(sMOREMSG_OFF,"");
    strcpy(sMOREMSG_WORD_OFF,"");
    strcpy(sINPUT_BOX,"");
    strcpy(sTEXT_COLOR,"");
    strcpy(sTEXT_HILIGHT,"");
    strcpy(sMAX_AREAS,"");
    strcpy(sANSI_FILE,"");
    strcpy(sANSI_HELP,"");
    strcpy(sTHEME_NAME,"");
    strcpy(sMENU_PROMPT,"");
    strcpy(sMENU_PROMPT2,"");


    std::string path = INIPATH;
    path += "msgarea.ini";

    FILE *stream;
    stream = fopen(path.c_str(),"rb+");
    if(stream == NULL)
    {
        perror("Error unable to read msgarea.ini, check permissions!");
        return false;
    }
    fclose(stream);
    return true;
}

/**
 * Message Area INI - Generate Default INI (Deprecated)
 */
void msgarea_ini::msga_create()
{

    std::string name = INIPATH;
    name += "msgarea.ini";

    ofstream outStream2;
    outStream2.open( name.c_str(), ofstream::out | ofstream::trunc );
    if (!outStream2.is_open())
    {
        printf( "\nError Creating: %s \n", name.c_str());
        return;
    }

    outStream2 << " * Generated By Program. " << endl;
    outStream2.close();
    return;
}

/**
 * MenuArea INI - Parse Helper
 */
void msgarea_ini::msga_chkpar(std::string &data)
{

    std::string temp1;
    std::string::size_type st1 = 0;
    std::string::size_type st2 = 0;
    std::string::size_type ct  = 0;

    st1 = data.find('"', 0);
    st2 = data.find('"', st1+1);
    ++st1;
    temp1 = data.substr(st1,st2);
    ct = st2 - st1;
    if (temp1.length() > ct)
        temp1.erase(ct,temp1.length());
    data = temp1;
}

/**
 * Message Area INI - Get INI Values
 */
void msgarea_ini::msga_check(std::string cfgdata)
{

    int id1 = 0;
    std::string temp = cfgdata;
    if (temp[0] == '#') return;
    else if (temp.find("set TOP ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        id1 = atoi(temp.c_str());
        iTop = id1;
    }
    else if (temp.find("set BOT ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        id1 = atoi(temp.c_str());
        iBot = id1;
    }
    else if (temp.find("set THEME_NAME ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sTHEME_NAME,(char *)temp.c_str());
    }
    else if (temp.find("set ANSI_FILE ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sANSI_FILE,(char *)temp.c_str());
    }
    else if (temp.find("set ANSI_HELP ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sANSI_HELP,(char *)temp.c_str());
    }
    else if (temp.find("set MENU_PROMPT ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sMENU_PROMPT,(char *)temp.c_str());
    }
    else if (temp.find("set MENU_PROMPT2 ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sMENU_PROMPT2,(char *)temp.c_str());
    }
    else if (temp.find("set PAGENUM ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sPAGENUM,(char *)temp.c_str());
    }
    else if (temp.find("set PAGETOTAL ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sPAGETOTAL,(char *)temp.c_str());
    }
    else if (temp.find("set MOREUP ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sMOREUP,(char *)temp.c_str());
    }
    else if (temp.find("set MOREUP_CHAR ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sMOREUP_CHAR,(char *)temp.c_str());
    }
    else if (temp.find("set MOREDOWN ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sMOREDOWN,(char *)temp.c_str());
    }
    else if (temp.find("set MOREDOWN_CHAR ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sMOREDOWN_CHAR,(char *)temp.c_str());
    }
    else if (temp.find("set MOREMSG_ON ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sMOREMSG_ON,(char *)temp.c_str());
    }
    else if (temp.find("set MOREMSG_WORD_ON ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sMOREMSG_WORD_ON,(char *)temp.c_str());
    }
    else if (temp.find("set MOREMSG_OFF ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sMOREMSG_OFF,(char *)temp.c_str());
    }
    else if (temp.find("set MOREMSG_WORD_OFF ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sMOREMSG_WORD_OFF,(char *)temp.c_str());
    }
    else if (temp.find("set INPUT_BOX ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sINPUT_BOX,(char *)temp.c_str());
    }
    else if (temp.find("set TEXT_COLOR ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sTEXT_COLOR,(char *)temp.c_str());
    }
    else if (temp.find("set MAX_AREAS ", 0) != std::string::npos)
    {
        msga_chkpar(temp);
        strcpy(sMAX_AREAS,(char *)temp.c_str());
    }
}

/**
 * Message Area INI - Read & Parse INI File
 */
int msgarea_ini::msga_parse(int idx)
{

    if (!msga_exists())
    {
        perror("Error unable to read msgarea.ini, check permissions!");
        return 0;
    }

    //msga_create();

    char name[255]= {0};
    char name2[255]= {0};

    sprintf(name,"%smsgarea.ini",INIPATH);
    sprintf(name2,"%smsgarea%i.ini",INIPATH,idx);

    if (idx != 0) strcpy(name,name2);

    // Check if Theme Exists, if not return FALSE.
    FILE *stream;
    stream = fopen(name,"rb+");
    if(stream == NULL)   // File is not Present
    {
        return FALSE;
    }
    else
    {
        fclose(stream);
    }

    ifstream inStream;
    inStream.open( name );
    if (!inStream.is_open())
    {
        perror("Error unable to parse msgarea.ini, check permissions!");
        return FALSE;
    }

    std::string cfgdata;
    for (;;)
    {
        getline(inStream,cfgdata);
        msga_check(cfgdata);
        if(inStream.eof()) break;
    }
    inStream.close();
    return TRUE;
}


/**
 * Message Area - Read & Parse INI File
 */
msg_area::msg_area()
{

    tTop     = 1;
    tBot     = 1;
}


/**
 * Message Area - Startup
 */
void msg_area::init_db()
{


    /*
    bbs_cfg bcfg;
    bcfg.parseconfig();

    // Setup in Config file now.
    std::string node = bcfg.SQL_LOGINSERVER,
        base = bcfg.SQL_DATABASENAME,
        user = bcfg.SQL_LOGINNAME,
        pass = bcfg.SQL_LOGINPASSWORD;

    StderrLog       log;
    std::string     err;
    Database::Mutex mutex;

    Database db(mutex,node,user,pass,base, (IError*)&log);
    Query q(db);
    if (!q.Connected()) {
        cout << "\r\nSQL: Not Connected!" << endl;
    }
    StartList(q);
    */
    StartList();
}

/**
 * Message Area - Read Areas and populate vector list.
 * along with status and flags.
 */
vector< mb_list_rec > msg_area::read_areas()
{

    /*
    bbs_cfg bcfg;
    bcfg.parseconfig();

    // Setup in Config file now.
    std::string node = bcfg.SQL_LOGINSERVER,
        base = bcfg.SQL_DATABASENAME,
        user = bcfg.SQL_LOGINNAME,
        pass = bcfg.SQL_LOGINPASSWORD;

    StderrLog       log;
    std::string     err;
    Database::Mutex mutex;

    Database db(mutex,node,user,pass,base, (IError*)&log);
    Query q(db);
    if (!q.Connected()) {
        cout << "\r\nSQL: Not Connected!" << endl;
    }*/

    SESSION s;
    mb_list_rec mbl;
    std::vector< mb_list_rec > result;

//    s . errlog((char *)"read_areas");

    ulong idx = 0; //Start at 1, 0 is Email, skip email is public area listing
    while(read_mbaselist(&mbl,idx))
    {
        mbl . idx = idx;
        result . push_back(mbl);
        ++idx;
    }

    /*
        ulong in = 0;
        q . get_result("SELECT msg_area, msg_desc, msg_type, msg_status, msg_group_id, msg_security_id FROM marea_cfg order by sortorder");
        ulong numrows = q . num_rows(); // get how many rows returned.

        //cout << "\r\nNumrows: " << numrows << endl;
        s . errlog((char *)"Numrows: ",numrows);

        in = 0;
        while(q . fetch_row()) {
            //s . errlog((char *)"loop");
            ++in;
            std::string str;

            str = q . getstr(0);
            //s . errlog((char *)"msg_area: %s",str.c_str());
            snprintf((char *)mbl . msg_area, sizeof(mbl . msg_area), "%s", str.c_str());

            str = q . getstr(1);
            //s . errlog((char *)"msg_desc: %s",str.c_str());
            snprintf((char *)mbl . msg_desc, sizeof(mbl . msg_desc), "%s", str.c_str());

            mbl . msg_type         = q . getval(2);
            mbl . msg_status       = q . getval(3);
            mbl . msg_group_id     = q . getval(4);
            mbl . msg_security_id  = q . getval(5);

            result . push_back(mbl);
        }


        //s . errlog((char *)"read_areas cnt: %lu", in);
        q . free_result();

        s . errlog((char *)"read_areas Done!");

        // Just looping through to test results not really needed.
        ulong max_areas = result.size();
        s . errlog((char *)"vector max_areas: %lu",max_areas);
    */


    /*  Testing.
    for (ulong i = 0; i != max_areas; i++) {
        s . errlog((char *)"vector str1: %s",(char *)result[i].msg_area);
        s . errlog((char *)"vector str2: %s",(char *)result[i].msg_desc);
    } */
    return result;
}


/**
 * Message Area - Builds Message Areas And Returns Vecotrs of
 *                Ansi Lightbars for (4) Different States
 *                User is shown 1 of 4 depending on the curent
 *                area and if there are new messages.
 */
vector< list_bar > msg_area::build_arealist(UserRec *usr, std::string &temp)   //, Query &qry) {
{

    mb_list_rec mbl;

    list_bar                 mbar;
    std::vector<list_bar>    result;
    std::vector<mb_list_rec> mareas;

    SESSION       s(usr); // Pass User Incase there are MCI Codes for User Info.

//    s . errlog((char *)" * build_areas * ");

    int c = 0;
    //std::string temp = "";
    std::string path  = "";
    std::string temp3 = "";
    temp.erase();


    FILE *inStream;
    long  idx = 1;
    long  cnt = 0;
    long  i   = 0;
//    long  basenum = 0;
//    long  lr  = 0;

    char  MCI[3]= {0};
    char  temp2[100]= {0};
    int   space  = 0;
    int   foundr = FALSE;
    int   foundl = FALSE;
//    int   reset  = FALSE;
//    int   dont   = FALSE;

    std::string ans  = "";
    std::string ans1 = "";
    std::string ans2 = "";
    std::string ans3 = "";
    std::string ans4 = "";

    // Prefetch ansi's
    path = ANSIPATH;
    path += "mareamid1.ans";
    if ((inStream = fopen(path.c_str(), "r+")) ==  NULL)
    {
        return result;
    }
    while (c != EOF)
    {
        c = getc(inStream);
        if (c != EOF) ans1 += c;
    }
    fclose(inStream);
    c = '\0';
    path = ANSIPATH;
    path += "mareamid2.ans";
    if ((inStream = fopen(path.c_str(), "r+")) ==  NULL)
    {
        return result;
    }
    while (c != EOF)
    {
        c = getc(inStream);
        if (c != EOF) ans2 += c;
    }
    fclose(inStream);
    c = '\0';
    path = ANSIPATH;
    path += "mareamid3.ans";
    if ((inStream = fopen(path.c_str(), "r+")) ==  NULL)
    {
        return result;
    }
    while (c != EOF)
    {
        c = getc(inStream);
        if (c != EOF) ans3 += c;
    }
    fclose(inStream);
    c = '\0';
    path = ANSIPATH;
    path += "mareamid4.ans";
    if ((inStream = fopen(path.c_str(), "r+")) ==  NULL)
    {
        return result;
    }
    while (c != EOF)
    {
        c = getc(inStream);
        if (c != EOF) ans4 += c;
    }
    fclose(inStream);

    int area_cnt = 0;

    /*
    qry.get_result("SELECT COUNT(*) FROM marea_cfg");
    qry.fetch_row();
    basenum = qry.getval();
    qry.free_result();
    */
    //while(read_mbaselist(&mb,idx)) {
    // Read All Areas
    mareas          = read_areas();

    long num_areas = 0;
    long max_areas = mareas.size();


    //s . errlog((char *)"build_arealist basenum   %lu", basenum);
//    s . errlog((char *)"build_arealist max_areas %lu", max_areas);
    usr->lastmsg = 0;

    while(area_cnt < max_areas)
    {

        if (num_areas == max_areas) break;
        mbl = mareas[num_areas];

//		s . errlog((char *)"build_arealist mbl . idx %lu", mbl.idx);

        ++num_areas;
        ++idx;

        ans = ans2; // Display HighLight None.
        ans = ans1; // Dispaly Lowlight None

        ans = ans4; // Dispaly HighLight (New Messages)
        ans = ans3; // Dispaly LowLight (New Messages)

//        reset = FALSE;
        temp3.erase();


        for (int icnt = 0; icnt < 4; icnt++)
        {

            switch (icnt)
            {
            case 0:
                ans = ans2;
                break; // Display HighLight None.  ON
            case 1:
                ans = ans1;
                break; // Dispaly Lowlight None    OFF

            case 2:
                ans = ans4;
                break; // Dispaly HighLight (New Messages)  ON
            case 3:
                ans = ans3;
                break; // Dispaly LowLight (New Messages)   OFF
            default:
                break;
            }

            i = 0;
            c = 0;
            do
            {
                memset(&MCI,0,sizeof(MCI));
                c = ans[i];
                if (c == '\0') break;

                // Check for Spacing MCI Code
                switch (c)
                {
                case '{' : // Left Justify
                    MCI[0] = ans[++i];
                    MCI[1] = ans[++i];
                    space = atoi(MCI);

                    if (space != 0)
                    {
                        foundl = TRUE;
                    }
                    else
                    {
                        temp3 += c;
                        temp3 += MCI;
                    }
                    break;

                case '}' : // Right Justify
                    MCI[0] = ans[++i];
                    MCI[1] = ans[++i];
                    space = atoi(MCI);

                    if (space != 0)
                    {
                        foundr = TRUE;
                    }
                    else
                    {
                        temp3 += c;
                        temp3 += MCI;
                    }
                    break;

                case '|' : // Pipe Codes
                    MCI[0] = ans[++i];
                    MCI[1] = ans[++i];
                    if (strcmp(MCI,"M#") == 0)
                    {
                        sprintf(temp2,"%i",area_cnt+1);
                        if (foundl)
                        {
                            s.lspacing(temp2,space);
                            foundl = FALSE;
                        }
                        else if (foundr)
                        {
                            s.rspacing(temp2,space);
                            foundr = FALSE;
                        }
                        temp3 += temp2;
                    }
                    else if (strcmp(MCI,"MA") == 0)
                    {
                        sprintf(temp2,"%s", (char *)mbl . mbdisplay);
                        if (foundl)
                        {
                            s.lspacing(temp2,space);
                            foundl = FALSE;
                        }
                        else if (foundr)
                        {
                            s.rspacing(temp2,space);
                            foundr = FALSE;
                        }
                        temp3 += temp2;
                    }
                    else if (strcmp(MCI,"MT") == 0)
                    {
                        cnt = CountMsgs(mbl . idx,usr);
                        if (cnt == -1) cnt = 0;
                        //else ++cnt;
                        sprintf(temp2,"%ld",cnt);
                        if (foundl)
                        {
                            s.lspacing(temp2,space);
                            foundl = FALSE;
                        }
                        else if (foundr)
                        {
                            s.rspacing(temp2,space);
                            foundr = FALSE;
                        }
                        temp3 += temp2;
                    }
                    else if (strcmp(MCI,"MN") == 0)
                    {

                        // Count how many unread messages
                        cnt = CountNewMsgs(mbl . idx,usr);

                        /*
                        if (cnt == -1) cnt = 0;
                        //else ++cnt;

                        lr = JamAreaGetLast(usr->idx,&mbl);
                        lr = 0;
                        if (lr == -1)   lr = 0;
                        if (lr > cnt )  lr = cnt;
                        else if (lr != 0) --lr;
                        if (cnt == 0)   lr = 0;

                        // Re-Process and Reset to Correct Mid Ansi
                        //if (cnt-lr >= 1 && reset == FALSE && (ans != ans2 || ans != ans4)) {
                        //    reset = TRUE;
                        //    goto RESTART;
                        //}

                        */

                        // sprintf(temp2,"%ld",cnt-lr);
                        sprintf(temp2,"%ld",cnt);
                        if (foundl)
                        {
                            s.lspacing(temp2,space);
                            foundl = FALSE;
                        }
                        else if (foundr)
                        {
                            s.rspacing(temp2,space);
                            foundr = FALSE;
                        }
                        // New Messages Setup count
                        if (cnt == 0)   // no new
                        {
                            mbar.isnew = FALSE;
                        }
                        else
                        {
                            mbar.isnew = TRUE;
                        }

                        temp3 += temp2;
                    }
                    else
                    {
                        temp3 += c;
                        temp3 += MCI;
                    }
                    break;

                case '\n' :
                    //  temp3 += '\r';
                    break;

                default :
                    temp3 += c;
                    break;
                }
                ++i;

            }
            while (c != '\0');

            temp3 += "\r";
            switch (icnt)
            {
            case 0:
                mbar . ansi_2 = temp3;
                break; // Display HighLight None.  ON
            case 1:
                mbar . ansi_1 = temp3;
                break; // Dispaly Lowlight None    OFF

            case 2:
                mbar . ansi_4 = temp3;
                break; // Dispaly HighLight (New Messages)  ON
            case 3:
                mbar . ansi_3 = temp3;
                break; // Dispaly LowLight (New Messages)   OFF
            default:
                break;
            }

            //result . push_back(mbar);
            //temp += temp3;
            temp3.erase();

        } // End of (4) Look for each string.

        /*
        s . errlog((char *)"mbar: 1 %s",mbar . ansi_1.c_str());
        s . errlog((char *)"mbar: 2 %s",mbar . ansi_2.c_str());
        s . errlog((char *)"mbar: 3 %s",mbar . ansi_3.c_str());
        s . errlog((char *)"mbar: 4 %s",mbar . ansi_4.c_str());


        s . pipe2ansi((char *)mbar . ansi_1.c_str());
        s . pipe2ansi((char *)mbar . ansi_2.c_str());
        s . pipe2ansi((char *)mbar . ansi_3.c_str());
        s . pipe2ansi((char *)mbar . ansi_4.c_str());
        */
        //s . startpause();

        result . push_back(mbar);
        temp3.erase();

        ++area_cnt;
        //s . errlog((char *)"area_cnt: %i",area_cnt);

    }
    // Update Clear Screen
//    s . errlog((char *)"build_areas Done!");
//    s . errlog((char *)"Done, import - return result vector list");
    return result;
}



/**
 * Message Areas - Parse ANSI Tempalte for MCI Codes (Area List)
 */
void msg_area::ParseHeader(char *filename)
{

    std::string temp;
    std::string path = ANSIPATH;
    path += filename;
    path += ".ans";

    mb_list_rec mr;

    char MCI[3]     = {0};   // Holds MCI Codes to Parse
    char sTemp[255] = {0};
    int  space = 0, foundr = 0 , foundl = 0;
//    int  c = 0;
    std::string buff;

    // Reads in Ansi file into Buffer Only
    readinAnsi(filename, buff);
    read_mbaselist(&mr, thisuser->lastmbarea);

    int id1 = 0;
    while (id1 != -1)
    {
        // parse justify spacing right / left passing in string before
        // replacing mci code. to Properly Space Output Ansi.
        id1 = buff.find("%", 0);
        if (id1 == -1) break;
        memset(&MCI,0,sizeof(MCI));
        space = 0;
        // Check if MCI Code is Justified then Process this.
        if (buff[id1+3] == '{')   // Left Justify
        {
            //elog("left justify: %c%c",buff[id1+4],buff[id1+5]);
            MCI[0] = buff[id1+4]; // Get first Digit
            MCI[1] = buff[id1+5]; // Get Second Digit
            space  = atoi(MCI);
            foundr = FALSE;
            foundl = TRUE;
        }
        else if (buff[id1+3] == '}')  // Right Justify
        {
            //elog("right justify: %c%c",buff[id1+4],buff[id1+5]);
            MCI[0] = buff[id1+4]; // Get first Digit
            MCI[1] = buff[id1+5]; // Get Second Digit
            space  = atoi(MCI);
            //elog("right justify: %i",space);
            foundl = FALSE;
            foundr = TRUE;
        }
        // Now Get MCI Code
        MCI[0] = buff[id1+1]; // Get first Digit
        MCI[1] = buff[id1+2]; // Get Second Digit

        memset(&sTemp,0,sizeof(sTemp));
        // Insert MCI Parsing here so we can reaplace full result with propering spacing.
        if (strcmp(MCI,"MA") == 0)
        {
            sprintf(sTemp,"%s", (char *)mr.mbdisplay);
        }
        else if (strcmp(MCI,"TH") == 0)
        {
            sprintf(sTemp,"%s", (char *)sTHEME_NAME);
        }


        // MCI Translation .
        if (foundl == TRUE)
        {
            lspacing(sTemp,space);
        }
        else if (foundr == TRUE)
        {
            rspacing(sTemp,space);
        }

        //If we Parsed Justify, then Erase that MCI Code as well.
        (space != 0) ?
        buff.replace(id1,6,sTemp):
        buff.replace(id1,3,sTemp);
    }
    //elog("Finished Parsing MCI Codes...");
    pipe2ansi((char *)buff.c_str());
}

/**
 * Message Areas - Setup The Area List,
 * Also check default Ansi Theme and set per user
 */
void msg_area::SetupList(UserRec *user)
{

    thisuser = user;
    // Check What Theme user has selected.
    if (msga_parse(thisuser->readertheme) == FALSE)
    {
        msga_parse();
    }
    tTop = iTop;
    tBot = iBot;
}

/**
 * Message Areas - Change Ansi Theme if available.
 */
int msg_area::change_theme(int idx)
{

    // Check What Theme user has selected.
    if (msga_parse(idx) == FALSE)
    {
        // Theme Doesn't Exist.
        return FALSE;
    }
    thisuser->readertheme = idx;

    // Save User Settings.
    UserRec usr;
    usr = *thisuser;
    users _usr;
    _usr.users_write(&usr,usr.idx);

    tTop = iTop;
    tBot = iBot;
    mLink.Top = tTop;
    mLink.Bot = tBot;
    return TRUE;
}


/**
 * Message Areas - Area List Startup.
 */
char *msg_area::StartList()
{

    bool more 		 = false;
    bool showmore    = false;
    char mString[10] = {0};
    unsigned char ch;
    std::string _output;
    char outBuffer[200];

    // Startup Friend Classes
    //language    _lang;
    menu_func   _mnuf;
    msg_readll  mLink;

    // Save User Settings.
    UserRec usr;
    usr = *thisuser;
    users _usr;

    // Then ReRead before passing copy to message system.
    _usr.users_write(thisuser,thisuser->idx);
    _usr.users_read(&usr,thisuser->idx);

//	 errlog((char *)"Build AreaList - ThisUserID %lu, %s",usr.idx, usr.handle);

    SESSION s(&usr);

    _mnuf.menu_setuser(thisuser);
    mLink.initList(sTEXT_COLOR, TRUE);

    mLink.Top = tTop;
    mLink.Bot = tBot;

    char rBuffer[1024]= {0};
    char text[1024]= {0};
    char sNum[3]= {0};
    std::string rBuff;

    std::string::size_type id1 = 0; //id2,
//    int num, num2;
    int len;

    std::string tmp;
//    UserRec trec;

    // For Next / Prev Message Areas
    int CurrentPage  = 0;
//    int PreviousPage = 0;
    int bSize        = 0;
    int boxsize      = 0;

    bSize = tBot - tTop;
    ++bSize;


    //CURRENT_MAREA   = 0;
    //usr.lastmbarea = 0;

    // Run through Main Loop until exit from user - This Loop Probably not needed anymore.
    vector<list_bar> result;

//    errlog((char *)"Build AreaList - UserID %lu, %lu",usr.idx, usr.handle);
    result = build_arealist(&usr, tmp); //, qry);

    mLink.GetVector(result);

    while (1)
    {
        // Jump to Current Page
        boxsize =  mLink.Bot - mLink.Top;
        CurrentPage = CURRENT_MAREA / boxsize;

        ParseHeader(sANSI_FILE);	      // Display Ansi
        //tmp.erase();

//        errlog((char *)"PutBuffer msg_area()");
        //  Make sure we have areas.
        if (result.size() > 0)
        {
            mLink.box_start_vector(CurrentPage,CURRENT_MAREA);            // Draw Message Inside of Box
        }
        else
        {
            return NULL;
        }

//        errlog((char *)"box_start done msg_area()");
        // Start Input Loop.
        while(1)
        {
            _output.erase();
            _output = "|16";
            more = false;
            showmore = false;
            //if (mLink.line_count() > 0) more = true;
            if (mLink.Page+1 != mLink.TotPages) more = true;

            // Show Down Arrow More!
            if (more)
            {
                sprintf(outBuffer,"%s\x19",sMOREDOWN); 	// On
                showmore = true;
            }
            else
            {
                sprintf(outBuffer,"%s ",sMOREDOWN);		// Off
            }
            _output += outBuffer;

            // Show up Arrow More
            if (mLink.Page > 0)
            {
                sprintf(outBuffer,"%s\x18",sMOREUP);
                showmore = true;
            }
            else
            {
                sprintf(outBuffer,"%s ",sMOREUP);
            }
            _output += outBuffer;

            if (showmore)
                sprintf(outBuffer,"%s%s",sMOREMSG_ON,sMOREMSG_WORD_ON);
            else
                sprintf(outBuffer,"%s%s",sMOREMSG_OFF,sMOREMSG_WORD_OFF);
            _output += outBuffer;

            // Show Current/Total Pages
            sprintf(outBuffer,"%s%.3d",sPAGENUM,mLink.Page+1);
            _output += outBuffer;
            sprintf(outBuffer,"%s%.3d",sPAGETOTAL,mLink.TotPages);
            _output += outBuffer;

            // # of Message Areas
            sprintf(outBuffer,"%s%d",sMAX_AREAS,mLink.Tot);
            _output += outBuffer;

            pipe2ansi((char *)_output.c_str());

            // Blank out the previous menu so we can reload, / redraw on restart.
            //memset(&_mnuf._premenu,0,sizeof(_mnuf._premenu));

            // Make Msgqp2 Prompt Optional, Use if exists!
            // Also Let user Toggle on / off
            if (_mnuf.cmdexist(sMENU_PROMPT2,0) /*&& thisuser->msgp2*/ )
            {
                if (more || mLink.Page > 1)
                {
                    _mnuf._curmenu.clear();
                    _mnuf._curmenu = sMENU_PROMPT2;
                }
                else
                {
                    _mnuf._curmenu.clear();
                    _mnuf._curmenu = sMENU_PROMPT;
                }
            }
            else
            {
                _mnuf._curmenu.clear();
                _mnuf._curmenu = sMENU_PROMPT;
            }

            // Readin the Menu Prompt and get or wait for input.
// So we don't reload all of the menu and propmts for a bad key, just ask again!
JMPINPUT:

            // Draw Input Box
            memset(&text,0, sizeof(text));
            strcpy(text,sINPUT_BOX);

            sprintf(outBuffer,"%d",mLink.Tot);
            len = strlen(outBuffer)+1; // Last Ourbuf is Message Number
            inputfield(text,len);

            _output = text;
            _output += "|16";
            pipe2ansi((char *)_output.c_str());


            _mnuf.menu_readin();
            _mnuf.menu_proc(mString);
            ch = mString[1];

            // For Menu CmdKey Input
            if (mString[0] == '!')
            {
                switch (toupper(ch))
                {
                case 'Q': // Quit
                    mLink.dispose_list();
                    //_mnuf.~menu_func();
                    memcpy(thisuser,&usr,sizeof(UserRec));
//						errlog((char *)thisuser->handle);
                    vector<list_bar>() . swap(result); // Free Vector Up.
                    return NULL; //qBuf;

                case 'U':  // UP
                    if (CurrentPage != 0)
                    {
                        --CurrentPage;

                        // Reset Bar to first Listing on each Page.
                        // CurrentPage = CURRENT_MAREA / boxsize;
                        CURRENT_MAREA = CurrentPage * boxsize;
                        mLink.box_start_vector(CurrentPage,CURRENT_MAREA);
                    }
                    else
                        goto JMPINPUT;
                    break;

                case 'D': // DN
                    if (CurrentPage+1 != mLink.TotPages)
                    {
                        ++CurrentPage;

                        // Reset Bar to first Listing on each Page.
                        // CurrentPage = CURRENT_MAREA / boxsize;
                        CURRENT_MAREA = CurrentPage * boxsize;
                        mLink.box_start_vector(CurrentPage,CURRENT_MAREA);
                    }
                    else
                        goto JMPINPUT;
                    break;

                case '+': // Next Area - Move Down

//		                s . errlog((char *)"CURRENT_MAREA+1: %i. Listing: %i ", CURRENT_MAREA+1,mLink.listing.size());
                    if (CURRENT_MAREA+1 == (signed)mLink.listing.size() || (signed)mLink.listing.size() == 0)
                        goto JMPINPUT;

                    ++CURRENT_MAREA;
                    thisuser->lastmbarea = CURRENT_MAREA;

//		                s . errlog((char *)"CurrentPage: %i. PreviousPage: %i ", CurrentPage, PreviousPage);
//		                s . errlog((char *)"boxsize: %i. TotPages: %i. Page: %i ", boxsize, mLink.TotPages,  mLink.Page);
//                    PreviousPage = CurrentPage;

                    //Calculate if we go down, ++Current Area, are we on next page or not.
                    // Becasue 0 Based, need to add +1
                    // Test if we moved to next page.
                    if (CURRENT_MAREA+1 < (boxsize*(CurrentPage+1))+1)
                    {
                        // Still on Same Page
                        if (mLink.listing[CURRENT_MAREA-1].isnew)
                        {
//								errlog((char *)"!!! isNEW = 'Y' 3");
//								s . errlog((char *)"CURRENT_MAREA+1 %i < (boxsize*CurrentPage+1)+1, %i",CURRENT_MAREA+1,boxsize*(CurrentPage+1)+1);
                            // Lowlight Current, then Highlight Next.
                            sprintf(rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, (char *)mLink.listing[CURRENT_MAREA-1].ansi_3.c_str());
//								s . errlog((char *)rBuffer);
                        }
                        else
                        {
//								errlog((char *)"!!! isNEW = 'N' 1");
//								s . errlog((char *)"CURRENT_MAREA+1 %i < (boxsize*CurrentPage+1)+1, %i",CURRENT_MAREA+1,boxsize*(CurrentPage+1)+1);
                            // Lowlight Current, then Highlight Next.
                            sprintf(rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, (char *)mLink.listing[CURRENT_MAREA-1].ansi_1.c_str());
//								s . errlog((char *)rBuffer);
                        }

                        _output += rBuffer;
                        mLink.current_selection += 1;
                        if (mLink.listing[CURRENT_MAREA].isnew)
                        {
///								errlog((char *)"!!! isNEW = 'Y' 4");
                            sprintf(rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, (char *)mLink.listing[CURRENT_MAREA].ansi_4.c_str());
//								s . errlog((char *)rBuffer);
                        }
                        else
                        {
//								errlog((char *)"!!! isNEW = 'N' 2");
                            sprintf(rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, (char *)mLink.listing[CURRENT_MAREA].ansi_2.c_str());
//								s . errlog((char *)rBuffer);
                        }
                        _output += rBuffer;
                        pipe2ansi((char *)_output.c_str());
                        _output.erase();
                        goto JMPINPUT; //Not moving down a page.
                    }
                    else
                    {
                        // Move to next Page!
//		                    s . errlog((char *)"DN - CURRENT_MAREA !< Move next Page");
                        ++CurrentPage;
                        mLink.box_start_vector(CurrentPage,CURRENT_MAREA);
                    }
                    break;

                case '-': // Previous Area - Move Up
                    // Skipping to JMPINPUT bypasses redraws, much faster!
                    if (CURRENT_MAREA != 0)
                        --CURRENT_MAREA;
                    else
                        goto JMPINPUT;

                    if (mLink.listing.size() == 0)
                        goto JMPINPUT;

                    thisuser->lastmbarea = CURRENT_MAREA;

//				        s . errlog((char *)"!!! CurrentPage: %i. PreviousPage: %i ", CurrentPage, PreviousPage);
//				        s . errlog((char *)"boxsize: %i. TotPages: %i. Page: %i ", boxsize, mLink.TotPages,  mLink.Page);
//                    PreviousPage = CurrentPage;

//						s . errlog((char *)"!!! CurrentPage: %i. PreviousPage: %i ", CurrentPage, PreviousPage);
                    //Calculate if we go down, --Current Area, are we on next page or not.
                    // Becasue 0 Based, need to add +1
                    // Test if we moved to next page.
                    if (CURRENT_MAREA+1 > (boxsize*(CurrentPage)))
                    {
                        // Still on Same Page
//				            s . errlog((char *)"CURRENT_MAREA+1 %i > (boxsize*CurrentPage+1)+1, %i",CURRENT_MAREA+1, ((boxsize*CurrentPage)+1) );
                        // Lowlight Current, then Highlight Next.
                        if (mLink.listing[CURRENT_MAREA+1].isnew)
                        {
//								errlog((char *)"!!! isNEW = 'Y' 1");
                            sprintf(rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, (char *)mLink.listing[CURRENT_MAREA+1].ansi_3.c_str());
//								s . errlog((char *)rBuffer);
                        }
                        else
                        {
//								errlog((char *)"!!! isNEW = 'N' 3");
                            sprintf(rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, (char *)mLink.listing[CURRENT_MAREA+1].ansi_1.c_str());
//								s . errlog((char *)rBuffer);
                        }

                        _output = rBuffer;
                        mLink.current_selection -= 1;

                        if (mLink.listing[CURRENT_MAREA].isnew)
                        {
//								errlog((char *)"!!! isNEW = 'Y' 4");
                            sprintf(rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, (char *)mLink.listing[CURRENT_MAREA].ansi_4.c_str());
//								s . errlog((char *)rBuffer);
                        }
                        else
                        {
//								errlog((char *)"!!! isNEW = 'N' 2");
                            sprintf(rBuffer, "\x1b[%i;%iH|16%s", mLink.current_selection, 1, (char *)mLink.listing[CURRENT_MAREA].ansi_2.c_str());
//								s . errlog((char *)rBuffer);
                        }
                        _output += rBuffer;

                        pipe2ansi((char *)_output.c_str());
                        _output.erase();
//							s . errlog((char *)"CurrentPage: %i. PreviousPage: %i ", CurrentPage, PreviousPage);
//				            s . errlog((char *)"boxsize: %i. TotPages: %i. Page: %i ", boxsize, mLink.TotPages,  mLink.Page);
                        goto JMPINPUT; //Not moving down a page.
                        break;
                    }
                    else
                    {
                        // Move to next Page!
//				            s . errlog((char *)"2!!!! UP - CURRENT_MAREA !< Move prev Page");
//							s . errlog((char *)"First CurrentPage: %i. PreviousPage: %i ", CurrentPage, PreviousPage);
                        --CurrentPage;
//							s . errlog((char *)"Now CurrentPage: %i. PreviousPage: %i ", CurrentPage, PreviousPage);
//				            s . errlog((char *)"boxsize: %i. TotPages: %i. Page: %i ", boxsize, mLink.TotPages,  mLink.Page);

                        mLink.box_start_vector(CurrentPage,CURRENT_MAREA);
                        //goto JMPINPUT;
                    }
                    break;

                default : // Executing a menu command and returning back to list.
                    //goto JMPINPUT;
                    vector<list_bar>() . swap(result); // Free Vector Up.
                    tmp.erase();
                    result = build_arealist(&usr, tmp); //, qry);
                    mLink.GetVector(result);

                    ParseHeader(sANSI_FILE);
                    mLink.box_start_vector(CurrentPage,CURRENT_MAREA);
                    break;
                } // End Switch
            } // of IF [!]
            else
            {
                if (mString[0] == '#')
                {
//		            s . errlog((char *)"# - CURRENT_MAREA ");
                    // received Digit Input From Menu Prompt
                    memset(&rBuffer,0, sizeof(rBuffer));
                    memset(&text,0, sizeof(text));
                    strcpy(text,sINPUT_BOX);

                    sprintf(outBuffer,"%d",mLink.Tot);
                    len = strlen(outBuffer)+1; // Last Ourbuf is Message Number

                    inputfield(text,len);
                    pipe2ansi(text);
                    sprintf(sNum,"%c",ch);
                    getline(rBuffer,len,sNum);
//                    num = 0;
//                    num2 = 0;
                    // Catch any invalid input
                    id1 = atoi(rBuffer);

                    //if (id1 == 0)
                    //goto JMPINPUT;

                    // Verify Area Input Range.
                    if (id1 > mLink.listing.size() || id1 < 1)
                    {
//		                s . errlog((char *)"# - Incorrect Input");
                        // Redraw input box
                        memset(&text,0, sizeof(text));
                        strcpy(text,sINPUT_BOX);

                        sprintf(outBuffer,"%d",mLink.Tot);
                        len = strlen(outBuffer)+1; // Last Ourbuf is Message Number

                        inputfield(text,len);
                        pipe2ansi(text);
                        goto JMPINPUT;
                    }
                    else
                    {
//		                s . errlog((char *)"# - Jump to area id1 %i",id1);
                        //Justjump to area, then reset to page that area is in.
                        CURRENT_MAREA = id1-1;
                        thisuser->lastmbarea = CURRENT_MAREA;

                        // Jump to Current Page
                        CurrentPage = CURRENT_MAREA / boxsize;
//		                s . errlog((char *)"# - Jump to area box_start_vector - CurrentPage %i",CurrentPage);
                        ParseHeader(sANSI_FILE);
                        mLink.box_start_vector(CurrentPage,CURRENT_MAREA);
                        //           mLink.box_start_vector(CurrentPage);
                    }
                } // End if [#]
                else
                {
                    // Not #, Check for Escaped Key Input

                    ch = mString[0];
                    switch (toupper(ch))
                    {
                    case 'A':  // UP
                        if (CurrentPage != 0)
                        {
                            --CurrentPage;

                            // Reset Bar to first Listing on each Page.
                            CURRENT_MAREA = CurrentPage * boxsize;
                            mLink.box_start_vector(CurrentPage,CURRENT_MAREA);
                        }
                        else
                            goto JMPINPUT;
                        break;

                    case 'B': // DN
                        if (CurrentPage+1 != mLink.TotPages)
                        {
                            ++CurrentPage;
                            // Reset Bar to first Listing on each Page.
                            CURRENT_MAREA = CurrentPage * boxsize;
                            mLink.box_start_vector(CurrentPage,CURRENT_MAREA);
                        }
                        else
                            goto JMPINPUT;
                        break;

                    default :

                        vector<list_bar>() . swap(result); // Free Vector Up.
                        tmp.erase();
                        result = build_arealist(&usr, tmp); //, qry);
                        mLink.GetVector(result);

                        ParseHeader(sANSI_FILE);
                        mLink.box_start_vector(CurrentPage,CURRENT_MAREA);
                        break;

                    } // End Case
                }// End Else # or hokey.
            }// End of If Else [!]
        } // While(1)
    } // While(1) with redraw ansi
}


